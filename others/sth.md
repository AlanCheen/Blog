# 罗里吧嗦。



### 关于页面组件化以及动态化的一些思考



Native 开发的痛点：

1. **新需求的开发与老需求的迭代都跟客户端应用发版强绑定，周期长**：不管是新需求的开发还是老需求的迭代，开发完毕后依赖应用发版，都不能直接触达用户，需求迭代周期长；
2. **无法灵活地动态修改样式，UI 定制化成本高**：native 开发完 UI 后，基本就只有一个样式，即便只是换个颜色或字体大小，都需要客户端修改代码，然后发版上线，不灵活也不动态，成本太高；



为了解决上述的问题，需要引入**组件化**以及**动态化**，组件化用来降低 UI 定制开发的成本，动态化用来解决周期长的问题。

在策略上，要**“重后端，轻前端”**，让客户端只做数据绑定的工作，其他剩余的事情都交个后端或其他角色来处理。一个页面长什么样子，用什么组件，组件渲染成什么样子等等，这些在到达客户端之前都应该已经被决定好了。



#### 组件化的实现



**组件化可以用一套各方约定的协议来实现**。这套协议是页面的抽象，它需要描述清楚**一个页面到底长什么样子**，包含一个页面的所有信息，并且提供可配置的灵活性。例如配置某个组件的背景色。



具体来说它应该需要包含这些信息：

1. 组成一个页面所需要的所有的组件的信息，例如组件的类型和组件的标识等；
2. 组件的布局信息，也即如何用组件搭建该页面；
3. 组件的信息以及组件要绑定的数据；
4. 组件的事件信息，例如点击后跳转页面和发送请求的参数信息；



总结来说需要包含：页面结构、数据、行为。





##### 协议数据的生命周期



渲染一个页面需要各方通力合作，大概的流程：

1. 客户端带参发送请求；
2. 后端接受请求，查询业务数据；
3. 转化业务数据为协议数据；
4. 客户端接受协议数据并解析渲染；



`数据 BizModel ==> ComponentModel ==> 客户端解析 ==> 渲染`



这涉及到三个角色：

1. **后端**：接受前端发送来的请求，然后处理各种业务逻辑，获取数据，最终得到一个数据 Model；
2. **配置平台**：配置平台接受后端的数据 Model，然后进行处理，转换成一个组件化的协议数据，它包含页面的所有信息数据，例如页面用什么组件、组件如何排布以及组件的事件等，并且它能让客户端直接解析；
3. **客户端**：负责解析协议以及数据绑定；



##### 组件化的不足



1. **不支持复杂的布局**：组件化只能支持简单的组件布局，例如从上至下一次排布。假如要支持错乱的布局排布，用协议很难描述。

2. **增量更新难**：组件化协议基本上只能描述特定状态下的页面信息，如果要局部更新 UI 则很困难；
3. **分页不支持**：类似增量场景，协议也难支持分页模式；
4. **支持的交互简单**：协议只能抽象简单的交互，例如组件的点击或长按等很简单的交互，复杂的交互很难完美支持；
5. **组件之间的通信困难**：在协议下组件之间应该是完全解耦的，如果组件之间有互相依赖，那很难实现完美支持；



#### 动态化的实现



各个客户端约定一系列的 DSL 规则，制定一个模板规则，映射视图，通过下发模板规则来实现动态化。

通俗的讲就是通过制定一套模板，后端下发动态的模板，客户端解析然后根据模板渲染 UI。



例如基于 XML ，这样 Android 可以非常方便的支持。



#### 组件化+动态化的优势



#### 小结

组件化+动态化的实现需要**协议**、**服务端配置平台**以及**客户端容器**。

协议描述页面，配置平台进行页面配置，客户端实现动态化容器。


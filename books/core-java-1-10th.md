# 《Java 核心技术 卷 1 基础知识 第十版》

> 本文 GitHub 地址：https://github.com/AlanCheen/FullStackNotes
>
> 作者：程序亦非猿

---

[TOC]



基于 Java SE 8 更新。

Core Java Volume 1-Fundamentals



强类型语言，必须为每一个变量声明一种类型。



### 第 3 章 Java 的基本程序设计结构





#### 3.3 数据类型



8 种基本类型（primitive type），其中 4 种整形，2 种浮点类型、char、boolean。



| 类型    | 存储(字节) | 取值范围 |
| ------- | ---------- | -------- |
| int     | 4          |          |
| short   | 2          |          |
| long    | 8          |          |
| byte    | 1          | -128~127 |
|         |            |          |
| float   | 4          |          |
| doubule | 8          |          |
|         |            |          |
| char    |            |          |
| boolean |            |          |



#### 3.6 字符串

字符串 String，不可变，



#### 3.10 数组

数组是一种数据结构，用来存储同一类型值的集合。通过一个整形下标可以访问数组中的每一个值。

在声明数组变量时，需要指出数组类型（数组元素类型紧跟[]）和数组变量的名字 。如：`int[]a`、`int[]b = new int[]{1,2,3,4}`。



1. `foreach 循环语句`的循环变量将会遍历数组中的每个元素，而不需要使用下标值；更加简洁、更不容易出错。
2. `Arrays.copy` 来处理数组拷贝
3. `Arrays.sort`来排序，它用的是优化过的**快速排序算法**；



### 第 4 章 对象与类



传统的`结构化程序设计`通过设计一系列的过程 (即算法)来求解问题。 一旦确定了这些
过程， 就要开始考虑存储数据的方式。 这就是 Pascal 语言的设计者 Niklaus Wirth 将其著作命
名为《算法 + 数据结构 = 程序》( `Algorithms + Data Structures = Programs`, Prentice Hall, 1975 )
的原因。 需要注意的是， 在 Wirth 命名的书名中， 算法是第一位的， 数据结构是第二位的，这就明确地表述了程序员的工作方式。 首先要确定如何操作数据， 然后再决定如何组织数
据， 以便于数据操作。 而 OOP 却调换了这个次序， 将数据放在第一位， 然后再考虑操作数
据的算法。

#### 4.1.2类

类是构造对象的模板或蓝图。

对象中的数据成为实例域（instance field），操纵数据的过程称为方法（method）。

实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。仅通过方法与数据进行交互。

#### 4.1.3对象

对象的三个主要特性：

1. 对象的行为
2. 对象的状态
3. 对象的标识

#### 4.1.4类之间的关系

最常见的关系有：

1. 依赖，use-a，表示类 A 用到了 B，就可以说 A 依赖 B，比如 A 调用了 B 的方法；
2. 聚合，has-a，表示类 A 的对象包含了 类B的对象；
3. 继承，is-a



#### 4.8 类路径

```java -classpath``` 命令来设置类路径



或者通过设置 CLASSPATH 环境变量来完成。



#### 4.9 文档注释

1. @author
2. @version
3. @since
4. @deprecated
5. @see



注释文档抽取：

```javadoc -d docDirectory nameOfPackage```



#### 4.10 类设计技巧

1. 一定要保证数据私有，绝对不要破坏封装性。
2. 一定要对数据初始化
3. 不要在类中使用过多的基本类型，用类来替代多个相关的基本类型的使用会更加易于理解且易于修改；
4. 不是所有的域都需要独立的域访问器和域更改器；
5. 将职责过多的类进行分解；
6. 类名和方法名要能够体现它们的职责；
7. 优先使用不可变的类；



### 第 5 章 继承



### 第 6 章 接口、lambda 表达式与内部类



### 第 7 章 异常、断言和日志



所有异常都是由 Throwable 继承而来，但是分 Error 和 Exception。



#### 7.2.4 finally

finally 子句不管是否有异常被捕获，`finally 中的代码都会被执行`。

当 finally 句中包含 return 语句时，将会出现意想不到的结果。

*假设利用 return 语句从 try 语句块中退出。在方法返回前，finally 语句中的内容将被执行。如果 finally 句中也有一个 return 语句，这个返回值将会`覆盖原始的返回值`*。

```java
public static int f(int n) {
try {
	int r = n * n;
	return r; 
} finally{
	if (n = 2) return 0; }
}
```

如果调用 f(2), 那么 try 语句块的计算结果为 r = 4, 并执行 return 语 句 然 而， 在方法真
正返回前，还要执行finally子句。finally子句将使得方法返回0, 这个返回值覆盖了原
始的返回值 4。

#### 7.2.5 带资源的 try 语句

try-catch-with-res 是 Java7 的特性。

注释: 带资源的 try 语句自身也可以有 catch 子句和一个 finally 子句。 这些子句会在
关闭资源之后执行。 不过在实际中， 一个 try语句中加入这么多内容可能不是一个好
主 意。

#### 7.3 使用断言

断言机制运行在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走。

Java 引入了关键字 `assert`，使用方法有两种：

- assert 条件
- assert 条件：表达式



如果条件为 false，则会抛出一个 AssertionError 异常。



默认情况下断言是被禁用的，是利用 ClassLoader 来实现的。



### 第 8 章 泛型程序设计



### 第 9 章 集合

#### 9.1 

集合类将接口与实现分离。

队列，先进先出，通常有两种实现方式：

1. 一种是使用`循环数组`，效率比链表更高，但是是个有界集合，容量有限；
2. 另一种是使用`链表`，效率相对低，但容量无限。



Iterator.next 方法跟 remove 方法相互依赖，如果没有调用 next 就调用 remove 则会报错，也就是说调用 remove前必须调用 next，并且 remove 移除的就是上一次调用 next 方法时返回的元素。

![image-20190725201419186](http://ww3.sinaimg.cn/large/006tNc79ly1g5ccitlm10j30sw0lggy4.jpg)





### 第 13 章 部署 Java 应用程序





### 第 14 章 并发












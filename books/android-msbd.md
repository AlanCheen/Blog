# 《Android 面试宝典》黑马程序员

★★☆☆☆，很一般啊





43个笔记

3.3 四大组件的热点问题

 

（1）standard模式

standard是Activity的默认启动方式，这种方式的特点是，每启动一个Activity就会在栈顶创建一个新的实例。实际开发中，闹钟程序通常采用这种模式。standard启动模式的原理如图3-3所示。

 

 

（2）singleTop模式

使用singleTop模式启动Activity时，首先会判断要启动的Activity实例是否位于栈顶，如果位于栈顶则直接复用，否则创建新的实例。

 

 

（3）singleTask模式

singleTask模式可以保证某个Activity在整个应用程序中只有一个实例，当Activity的启动模式指定为singleTask时，则每次启动该Activity时，系统首先会检查栈中是否存在当前Activity实例，如果存在则直接使用，并把当前Activity之上的所有实例全部出栈，否则会重新创建一个实例。

 

 

（4）singleInstance模式

指定为singleInstance模式的Activity会启动一个新的任务栈来管理Activity实例，无论从哪个任务栈中启动该Activity，该实例在整个系统中只有一个。

 

 

Activity采用singleInstance模式启动分两种情况：一种是要启动的Activity不存在，则系统会先创建一个新的任务栈，然后再创建Activity实例。一种是要启动的Activity已存在，无论当前Activity位于哪个程序哪个任务栈中，系统都会把Activity所在的任务栈转移到前台，从而使Activity显示。实际开发中，来电界面通常采用这种模式。

 

 

扩展2：Intent与PendingIntent的区别。

 

 

Intent与PendingIntent的区别主要有以下几点：

（1）Intent是即时启动，随所在的Activity消失而消失，而PendingIntent用于处理非即时Intent。

（2）Intent在程序结束后终止，而PendingIntent在程序结束后依然有效。

（3）Intent需要在某个Context内运行，而PendingIntent自带Context。

（4）Intent在原Task中运行，而PendingIntent在新的Task中运行。

（5）Intent一般用于Activity、Service、BroadcastReceiver之间传递数据，而Pendingintent一般用于消息通知上，可以理解为延迟执行的Intent。

 

 

Service的启动方式有以下两种：

（1）调用startService（）启动：这种方式启动的Service会长期在后台运行，即使启动它的应用组件已经被销毁，该服务还是会运行。若资源不足时，则服务可能会被杀死；当资源足够时，服务又会被重新启动。

（2）调用bindService（）启动：这是一种“绑定”状态的Service，一个绑定的Service提供一个允许组件与Service交互的接口，可以发送请求、获取返回结果，还可以通过跨进程通信来交互（IPC）。绑定的Service只有当应用组件绑定后才能运行，多个组件可以绑定一个Service，被绑定的服务的生命周期会跟调用者关联起来，调用者退出，服务也会跟着被销毁。通过绑定服务，可以间接调用服务内部的方法（借助onBind（）方法返回IBinder实现类）。当调用unbind（）方法时，该Service就会被销毁。

 

 

经典面试9：广播有几种类型？

 

 

广播有两种类型，分别为无序广播和有序广播。

（1）无序广播：该广播是调用sendBroadcast（）方法来发送广播的。无序广播不可以被拦截，若被拦截，则会报错。所有接收无序广播的广播接收者在此广播被发送时均能接收到该无序广播。无序广播的广播接收者之间不能相互传递数据。

（2）有序广播：该广播是调用sendOrderedBroadcast（）方法来发送广播的，同时也可以调用abortBroadcast（）方法来拦截该广播。有序广播的广播接收者可以在清单文件中，通过标签设置“android：property”属性来设置优先级，优先级高的接收者可以拦截优先级低的。在相同优先级下，广播接收者接收的顺序要看接收者在清单文件中声明的顺序，先声明的接收者比后声明的接收者要先接收到广播。有序广播的广播接收者之间可以互相传递数据。

 

 

经典面试10：广播接收者有几种注册方式？

 

 

广播接收者（BroadcastReceiver）分为两种注册方式：

（1）静态注册：直接在AndroidManifest.xml文件中进行注册，通过该方式注册的广播接收者在系统中运行一次后就会被注册到系统中，以后无须运行该应用程序也可以接收到广播。

（2）动态注册：无须在AndroidManifest.xml文件中注册组件，直接在代码中通过调用Context的registerReceiver（）方法即可在程序中动态注册广播接收者。通过这种注册方式注册的广播接收者，只有在代码运行时，广播接收者才生效。若代码运行结束，则广播接收者也即失效。

 

3.7 网络交互的热点问题

 

经典面试1：简述HTTP协议的特点。

【答案说明】

HTTP（Hyper Text Transfer Protocol，超文本传输协议）是一种请求/响应式的协议，客户端在与服务器端建立连接后，即可向服务器端发送请求，这种请求被称作HTTP请求，服务器端接收到请求后会做出响应，称为HTTP响应。

 

 

HTTP协议的特点总结如下：

1.简单快速

客户端向服务器请求服务时，只需传送请求方式和路径。常用的请求方式有GET、POST等，每种方式规定了客户端与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

￼

图3-9　客户端与服务器的交互过程

2.灵活

HTTP允许传输任意类型的数据，正在传输的数据类型由Content-Type加以标记。

3.无状态

HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力，如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。

 

 

HTTP协议是一种基于TCP协议的通讯协议。由于TCP协议提供传输控制，按顺序组织数据和错误纠正，因此HTTP协议使用TCP协议而不是UDP协议。

 

 

经典面试3：POST请求有几种形式？

【答案说明】

HTTP协议中POST请求的形式有以下几种：

（1）数据以表单的形式请求，该形式结构单一且烦琐。具体代码如下：

￼

（2）数据以JSON字符串的形式请求，该形式比较灵活，开发中一般常用。具体代码如下：

￼

（3）数据以文件的形式请求，该形式使用httpmime-4.3.jar+httpclient，主要处理单张或多张图片上传。

 

4.1 线程的热点问题

 

上述构造方法中有7个参数，下面针对每个参数进行简要说明：

（1）corePoolSize：线程池维护线程的核心线程数。

（2）maximumPoolSize：线程池维护线程的最大数量。

（3）keepAliveTime：线程池维护线程所允许的空闲时间。

（4）unit：线程池维护线程所允许的空闲时间的单位。

（5）workQueue：线程池所使用的缓冲队列。

（6）threadFactory：新建线程工厂。

（7）handler：线程池对拒绝任务的处理策略。

 

4.2 多媒体的热点问题

 

经典面试1：Android中有几种动画？

【答案说明】

Android中动画有3种，分别是Tween Animation（补间动画）、Frame Animation（帧动画）、Property Animation（属性动画）。

1.Tween Animation

Tween Animation（补间动画）是通过特定对象让视图组件展示出旋转、平移、缩放、改变透明度等一系列动画效果的过程，该动画不会改变原有控件的位置。根据动画效果的不同，补间动画又可分为旋转动画、平移动画、缩放动画、透明度渐变动画4种。

2.Frame Animation

Frame Animation（帧动画）是通过加载一系列的图片资源，按照顺序播放排列好的图片，该动画具有很大的灵活性，很适合展现比较细腻的动画，如电影。

3.Property Animation

Property Animation是Android 3.0引入的一个新动画，Property Animation和Tween Animation的使用基本没有区别，但是Property Animation可以改变控件的属性。另外，该动画为了兼容Android 3.0以下的版本可以使用NineOldAndroids类库。

 

4.3 机制的热点问题

 

扩展：什么是事件驱动程序设计模型？

事件驱动模型典型的应用是在GUI系统中，GUI系统中的应用程序要在不确定的时间里响应用户的UI事件。如果是传统的编程模型，应用程序必须有个线程去轮询GUI系统以便及时发现并处理消息，但这是非常浪费CPU资源的。

而事件驱动程序设计模型解决了这个问题，事件驱动程序模型有以下特点：

（1）有一个消息队列，存放消息。

（2）有一个轮询器，不停轮询消息队列，如果没有消息，那轮询器就会休眠。

（3）有消息实体，而且每个消息都与一个处理消息的Handler绑定。Handler的生命周期都很短。

这样的话，在没有消息时CPU就不用空转，而有了消息之后再唤醒该线程。这样还有一个好处，就是这个线程不仅可以处理UI的事件，其他的事件同样可以发到该消息队列中。

 

 

AsyncTask与Handler都适用于简单的异步处理，相比之下AsyncTask更轻量级（只是代码上轻量一些，而实际上要比Handler更耗资源）。

AsyncTask与Handler的优缺点如表4-2所示。

表4-2　AsyncTask与Handler的优缺点

￼

经典面试4：Android中如何进行事件分发？

【答案说明】

很多Android开发者都遇到过手势冲突的情况，一般都是通过内部拦截和外部拦截来解决此类问题。

 

 

经典面试4：Android中如何进行事件分发？

【答案说明】

很多Android开发者都遇到过手势冲突的情况，一般都是通过内部拦截和外部拦截来解决此类问题。若想明白该原理，则需要了解View的分发机制。首先了解dispatchTouchEvent（）、onInterceptTouchEvent（）、onTouchEvent（）这3个方法。

dispatchTouchEvent（）方法是用于处理事件分发的，若事件能够传递到当前View，则一定会调用该方法。View中该方法的源码如下：

￼

接下来，通过一个图例对上述代码中的方法进行详细分析，如图4-2所示。

￼

图4-2　事件分发U型图

图4-2中，从左往右依次是Activity、ViewGroup、View。

（1）事件从左侧的Activity中的dispatchTouchEvent（）方法开始做事件分发；

（2）箭头中间的字代表方法的返回值（return true、return false、return super.×××××（）），super的意思是调用父类实现。

（3）onInterceptTouchEvent（）：该方法是在dispatchTouchEvent（）方法中调用，用于判断是否需要截获事件，若该方法返回为true，则调用onTouchEvent（）方法并消费该事件；若返回false，则调用子View的dispatchTouchEvent（）方法将事件交由子View来处理。

（4）onTouchEvent（）：该方法也是在dispatchTouchEvent（）方法中调用，用于处理点击事件，包括ACTION_DOWN、ACTION_MOVE、ACTION_UP。若该方法返回为false，则表示不消费该事件，也不会截获接下来的事件序列。若返回为true，则表示当前View消费该事件。

以上事件通过一个例子来总结，爷爷有一个苹果，舍不得吃，给了爸爸，爸爸也舍不得吃，给了孙子（爸爸的儿子）。在这个过程中是都不拦截，向下分发。如果爷爷吃了，那就不分发，事件被拦截。同理，到了爸爸那一级也可以不分发、拦截。孙子只有两个决定，要么消费，要么回传。对应的例子就是吃掉它或者不吃。

 

 

经典面试5：Android中如何进行消息推送？

 

 

消息推送的实现方式有两种，具体描述如下：

·　客户端使用Pull（拉）的方式：这种方式是客户端隔一段时间去服务器上获取一下信息，看是否有最新信息。

·　服务器使用Push（推送）的方式：这种方式是当服务器端有新信息时，服务器把最新信息推送到客户端上。

综上所述，Pull方式不仅比较耗费客户端的网络流量和手机电量，同时还需要客户端不停地去监测服务器的变化，因此一般都采用Push方式去推送消息。

 

 

（6）实现回调方法，最终实现第三方登录。

（7）QQ第三方登录成功后，可以获取用户的昵称和用户头像，唯一的openId等，此时根据后台接口文档，使用这些第三方信息为用户完成注册。

经典面试8：简述你对AIDL的理解。

【答案说明】

在Android中，出于安全性考虑，Android系统中的进程之间不能共享内存，每个应用都执行在自己的进程中，无法直接调用其他应用的资源。为了使应用程序之间能够彼此通信，Android提供了IPC（Inter Process Communication，进程间通信）的一种独特实现：AIDL（Android Interface Definition Language，Android接口定义语言）。

 

 

经典面试8：简述你对AIDL的理解。

 

4.4 优化的热点问题

 

经典面试3：Android中有哪些引用？

【

 

 

这4种级别由高到低依次为Strong Reference（强引用）、Soft Reference（软引用）、Weak Reference（弱引用）和Phantom Reference（虚引用）。

 

 

1.强引用

一般情况下强引用是使用最普遍的引用，若内存中的对象具有强引用时，即使内存不足，宁可抛异常OOM使程序终止，垃圾回收器也不会回收它；若内存中的对象不再有任何强引用时，则垃圾回收器开始考虑可能要对此内存进行垃圾回收。

 

 

2.软引用

软引用可用于实现内存敏感的高速缓存，也可以和一个引用队列（ReferenceQueue）联合使用。当一个对象只具有软引用时，如果内存空间足够，则垃圾回收器就不会回收它；如果内存空间不足，则垃圾回收器就会回收该对象的内存。如果软引用所引用的对象被垃圾回收器回收，则Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

3.弱引用

与软引用相比，弱引用具有更短暂的生命周期，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

 

 

4.虚引用

“虚引用”顾名思义，就是形同虚设，主要用于跟踪对象被垃圾回收器回收的活动。与其他几种引用不同的是，虚引用并不会决定对象的生命周期，并且必须与引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

 

 

经典面试5：如何检测应用的内存泄露？

 

4.6 异常的热点问题

 

经典面试2：如何避免ANR异常？

【答案说明】

在Android设备上，如果你的应用程序出现了无响应的现象，则系统会向用户显示一个对话框，这个对话框称作应用程序无响应（Application Not Responding，ANR）对话框。用户可以选择让程序继续运行，也可以选择“强制关闭”。这种ANR对话框的出现严重影响用户体验，一个良好的程序是不允许出现ANR的，为了避免出现这种情况，在程序中对响应性能的设计很重要。

ANR一般分为如下3类：

（1）KeyDispatchTimeout（5seconds）：按键或触摸事件在特定时间内无响应（主要类型）。

 

 

经典面试2：如何避免ANR异常？

 

 

ANR一般分为如下3类：

（1）KeyDispatchTimeout（5seconds）：按键或触摸事件在特定时间内无响应（主要类型）。

（2）BroadcastTimeout（10seconds）：BroadcastReceiver在特定时间内无法处理完成。

（3）ServiceTimeout（20seconds）：Service在特定的时间内无法处理完成（小概率类型）。

 

 

为了避免出现ANR异常，在程序设计时应注意以下3点：

（1）避免在主线程中进行复杂耗时的操作，如发送或接收网络数据、进行大量计算、操作数据库、读写文件等。

（2）避免在BroadCastReceiver中进行复杂操作，若必须在BroadCastReceiver中进行复杂操作，则可以在onReceive（）方法中启动一个Service来处理。

（3）在设计与代码编写阶段避免出现同步、死锁以及错误处理不恰当等情况。

 

4.7 第三方框架的热点问题

 

经典面试5：什么是REST？

 

 

经典面试7：简述你对Retrofit库的理解？

 

 

Retrofit库有以下几个优点：

（1）性能最好，处理最快。

（2）使用REST API时非常方便。

（3）传输层默认使用OkHttp框架。

（4）支持NIO，同时也支持URL参数替换和查询参数。

（5）返回结果可转换为Java对象（JSON字符串或Protocol BuffersProtocol）。

（6）支持Multipart请求和文件上传。

 

4.9 程序打包的热点问题

 

NimbleDroid

 

 

APK瘦身的几种方式如下：

（1）开启混淆，删除无用的Java文件。开启minifyEnabled（开启混淆，删除无用的Java文件），可减小项目中APK文件的大小，具体代码如下：

￼

（2）去除无用资源，同时去除工程中临时展示的图片。开启shrinkResources（去除无用资源），同时去除工程中临时展示的图片可减小APK文件的大小，具体代码如下：

￼

（3）删除无用的语言资源。删除无用的语言资源可减小APK文件的大小，具体代码如下：

￼

（4）使用TinyPNG有损压缩。TinyPNG是一种智能有损压缩技术（通过降低图片中的颜色数量，来减少存储图片所需要的数据）来降低PNG图片的大小。这样的压缩对图片的效果影响是很小的，但是可大大降低图片的大小，并且还能保持PNG的透明度。

由于TinyPNG将PNG图片压缩成8位的，因此它的压缩比例非常高，至少有50％以上的压缩比例，有些甚至可达到70％，并且压缩之后的图片和原图人眼基本看不出区别。

（5）PNG图片换成JPG图片。对于非透明的大图，JPG将会比PNG的图片大小有显著的优势，在启动页、活动页等之类的大图展示区采用JPG将是非常明智的选择，这样可减小APK文件的大小。

（6）使用webp格式。从Android 4.0+开始原生支持，但是不支持包含透明度的webp，直到Android 4.2.1+才支持显示含透明度的webp，使用时要特别注意使用格式工厂进行转换。

（7）删除或者替换兼容包（v4、v7、v13）中无用的一些图。删除drawable-LDRTL（layout-direction-right-to-left的缩写），意味着布局方式从右到左，主要是为了适配阿拉伯语用。这应该是API17，即Android 4.2上新出的功能。

可以使用1×1像素的图片来替换v4、v7、v13中的一些图片资源。

（8）注意删除第三方库中使用的大图

（9）so库的删除。建议实际工作的配置只保留armeabi、x86文件夹下的so文件。

（10）通过v4包中的Drawable Compat，通过着色方案完成selector效果。通过v4包中的DrawableCompat，通过着色方案完成selector效果，具体代码如下：

￼

￼

 

 

（11）使用shape文件替换图片。使用shape文件替换图片，具体代码如下：

￼

（12）把so文件放置到网上或者sdcard内。

 

 

扩展：APK由哪些部分组成？

为了能够减小APK的大小，首先需要知道APK由哪些部分构成，然后针对每个部分做相应的优化工作，接下来介绍APK的组成：

（1）Classes.dex：是Java源码编译后生成的Java字节码文件。

（2）resources.arsc：编译后的二进制资源文件。

（3）AndroidManifest.xml：该文件是每个应用都必须定义和包含的，它描述了应用的名字、版本、权限、引用的库文件等信息。

（4）proguard.cfg：代码混淆的配置文件。

（5）project.properties：表示APK的target与sdk的依赖关系，这里的依赖关系指的是该APK依赖了哪些工程。

（6）assets：该目录用于存放一些配置文件。

（7）armeabi：该目录存放在lib目录下，用于存放一些so文件或者jar包。

（8）META-INF：该目录下存放的是签名信息，用来保证APK包的完整性和系统的安全性。

（9）res：该目录下存放的是资源文件，包括图片、字符串、raw文件夹下面的音频文件、各种XML文件等。

 
# 《Head First Java 》

[TOC]

### 1 基本概念

​	源代码
​	编译器
​	虚拟机

### 2 类与对象

​	

- 对象是靠类的模型塑造出来的
  		对象是已知的事物——实例变量
    		对象会执行的动作——方法
- 类是对象的蓝图
  		类不是对象，却是用来创建它们的模型 



### 3 primitive 主数据类型和引用 

​	

- 基本类型
-  引用类型，保存对象的引用
- ​	数组也是对象
- ​	对象放在堆里生存



### 4 方法操作实例变量

​	封装
​	*实例变量*声明在类内部（成员变量）
​	*局部变量*声明在方法内，使用前必须初始化



### 5 编写程序

### 6 认识 Java 的 API



### 7 继承与多态

​	在掌握多态之前，我们的薪水少的可怜。每天又得加班赶工。
​	继承概念下的 IS-A 是单向关系。

### 8 接口与抽象





### 9 构造器与垃圾收集器

​	

#### 内存的两种区域

​		堆 heap
​			对象
​		栈 stack
​			方法调用和局部变量
​	

#### 对象的生命周期

- 对象的引用没了，就会死亡
- 局部变量只会存活在声明的方法中
- 实例变量的寿命跟对象相同，对象活着它就还活着
  	

#### 释放对象引用的 3 个方式



1️⃣引用永久性的离开它的范围：

```java
void go(){
  Life z = new Life(); //z 会在方法结束时消失
}
```

z 会在方法结束时消失。



2️⃣引用被复制到其他的对象上：

```java
Life z = new Life();//第一个对象会在 z 被赋值到别处时挂掉
z = new Life();
```

第一个对象会在 z 被赋值到别处时挂掉。



3️⃣直接将引用设定为 null：

```java
Life z = new Life();//
z = null;
```

第一个对象会在 z 被赋值为 null 时击毙。



#### null 的真相

![image-20190617161804907](/Users/mingjue/self/FullStackNotes/books/assets/image-20190617161804907.png)



null 只是把引用清空了而已。

### 10 数字与静态



- **静态方法**
  		静态方法不能调用非静态变量
  		静态方法也不能调用非静态方法
- **静态变量**
  		静态变量的值对所有的实例来说都是相同的
  		静态变量是共享的，同一类所有的实例共享一份静态变量
  		静态变量是在类被加载时初始化的。
  		静态变量会在该类的任何静态方法执行之前就初始化。
- **静态的 final 变量是常数**
- **静态初始化程序**（`static initializer`）是一段在加载类时会执行的程序代码，它会在其他程序可以使用该类之前就执行，所以释放放静态 final 变量的起始程序。（static 代码块）



### 11 异常处理

### 12 图形用户接口

### 13 Swing

### 14 序列化和文件的输入/输出

​	`Serializable`
​	如果某实例变量不能或不应该被序列化，就把它标记为 `transient`（瞬时）



### 15 网络与线程



socket bufferreader

### 16 集合与泛型

- 数据结构
  - ArrayList 
  - TreeSet，以有序状态保持并可防止重复 
  - HashMap，可用成对的 name/value 来保存与取出 
  - LinkedList，针对经常插入或删除中间元素所设计的高效率集合。 
  - HashSet，防止重复的集合，可快速地找寻相符的元素 
  - LinkedHashMap，类似 HashMap，但可记住元素插入的元素，也可以设定成依照元素上次存取的先后来排序。
- 分类
  - List 知道索引
  - Set 不允许重复
  - Map 使用键值对，key 不能重复
- 泛型
  		更好的类型安全性




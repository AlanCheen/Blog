# 散列表 Hashtable

[TOC]

### 什么是散列表？



散列表（Hash table，也叫哈希表），是根据`键`（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找数据。

这个*映射函数称*作`散列函数`，`存放记录的数组称作散列表`。



就像我们的通讯录、字典那样，按照首字母作为关键字，并创建一个列表，这样通过首字母查找就方便多了。



#### 基本概念

- 若关键字为 k,则其值存放在 f(k)的存储位置上，这对应关系 f 称为`散列函数`，按这个思想建立的表为`散列表`
- 不同关键字可能会获得同一个散列地址，这样的现象称为`冲突`（collision）。具有相同函数值的关键字对散列函数来说是同义词。
- 根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“[像](https://zh.wikipedia.org/wiki/像_(數學))”作为记录在表中的存储位置，这种表便称为**散列表**，这一映射过程称为[散列造表](https://zh.wikipedia.org/wiki/散列)或[散列](https://zh.wikipedia.org/wiki/散列)，所得的存储位置称[散列地址](https://zh.wikipedia.org/w/index.php?title=散列地址&action=edit&redlink=1)。



所以



### 散列函数



散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。

1. 直接定址法
2. 数字分析法
3. 平方取中法
4. 折叠法
5. 随机数法
6. 除留余数法



Java 中的 `hashCode()`方法就是散列函数。



### 处理冲突



不管用什么散列函数，不发生冲突的可能性是非常小的，所以需要对冲突进行处理。

常用方法有一下几种：



1. `开放定址法`，
2. `单独链表法`，将散列到同一个存储位置的所有元素保存在一个链表中。
3. `双散列`，
4. `再散列`，在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生，这种方法不易产生“[聚集](https://zh.wikipedia.org/wiki/聚集)”（Cluster），但增加了计算时间。



[聚集](https://zh.wikipedia.org/wiki/聚集)（Cluster，也翻译做“堆积”）的意思是，在函数地址的表中，散列函数的结果`不均匀地`占据表的单元，形成`区块，`造成线性探测产生一次聚集（primary clustering）和平方探测的二次聚集（secondary clustering），散列到区块中的任何关键字需要查找多次试选单元才能插入表中，解决冲突，造成时间浪费。对于开放定址法，聚集会造成性能的灾难性损失，是必须避免的。



Java 中的 HashMap 早期就是用的 单独链表法，Java8 后会有个链表转红黑树的操作。



### 资料

https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8

